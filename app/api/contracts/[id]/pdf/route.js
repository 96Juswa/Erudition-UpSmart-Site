import { NextResponse } from "next/server";
import prisma from "@/app/lib/prisma";
import { PDFDocument, StandardFonts, rgb } from "pdf-lib";

export async function GET(req, contextPromise) {
  const { params } = await contextPromise;
  const contractId = parseInt(params.id, 10);

  if (isNaN(contractId)) {
    return NextResponse.json({ error: "Invalid contract ID" }, { status: 400 });
  }

  const contract = await prisma.contract.findUnique({
    where: { id: contractId },
  });

  if (!contract) {
    return NextResponse.json({ error: "Contract not found" }, { status: 404 });
  }

  // ✅ Replace peso symbol to avoid font encoding error
  const safeText = contract.text
    ? contract.text.replace(/₱/g, "PHP")
    : "No contract text available";

  const pdfDoc = await PDFDocument.create();
  let page = pdfDoc.addPage();
  const { width, height } = page.getSize();

  // Load fonts
  const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  const fontRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);

  const bodyFontSize = 11;
  const lineHeight = bodyFontSize + 6;
  const margin = 60;
  const maxWidth = width - margin * 2;

  let y = height - 80;
  let pageNumber = 1;

  // Helper function to add header to each page
  const addHeader = (currentPage) => {
    // Top border line
    currentPage.drawLine({
      start: { x: margin, y: height - 50 },
      end: { x: width - margin, y: height - 50 },
      thickness: 2,
      color: rgb(0.2, 0.2, 0.2),
    });

    // Contract title
    currentPage.drawText("CONTRACT AGREEMENT", {
      x: margin,
      y: height - 40,
      size: 16,
      font: fontBold,
      color: rgb(0.1, 0.1, 0.1),
    });

    // Contract ID on the right
    currentPage.drawText(`Contract ID: ${contractId}`, {
      x: width - margin - 120,
      y: height - 40,
      size: 10,
      font: fontRegular,
      color: rgb(0.3, 0.3, 0.3),
    });
  };

  // Helper function to add footer to each page
  const addFooter = (currentPage, pageNum) => {
    // Bottom border line
    currentPage.drawLine({
      start: { x: margin, y: 50 },
      end: { x: width - margin, y: 50 },
      thickness: 1,
      color: rgb(0.7, 0.7, 0.7),
    });

    // Footer text
    currentPage.drawText("Generated by UpSmart", {
      x: margin,
      y: 35,
      size: 8,
      font: fontRegular,
      color: rgb(0.5, 0.5, 0.5),
    });

    // Page number
    const pageText = `Page ${pageNum}`;
    const pageTextWidth = fontRegular.widthOfTextAtSize(pageText, 8);
    currentPage.drawText(pageText, {
      x: width - margin - pageTextWidth,
      y: 35,
      size: 8,
      font: fontRegular,
      color: rgb(0.5, 0.5, 0.5),
    });

    // Date
    const currentDate = new Date().toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric",
    });
    const dateWidth = fontRegular.widthOfTextAtSize(currentDate, 8);
    currentPage.drawText(currentDate, {
      x: (width - dateWidth) / 2,
      y: 35,
      size: 8,
      font: fontRegular,
      color: rgb(0.5, 0.5, 0.5),
    });
  };

  // Helper function to wrap text
  const wrapText = (text, maxWidth, font, fontSize) => {
    const words = text.split(" ");
    const lines = [];
    let currentLine = "";

    for (const word of words) {
      const testLine = currentLine ? `${currentLine} ${word}` : word;
      const testWidth = font.widthOfTextAtSize(testLine, fontSize);

      if (testWidth > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }

    if (currentLine) {
      lines.push(currentLine);
    }

    return lines;
  };

  // Add header to first page
  addHeader(page);

  // Helper function to draw signature section
  const drawSignatureSection = (currentPage, yPos) => {
    const signatureY = yPos - 30;
    const columnWidth = (maxWidth - 60) / 2;
    const leftX = margin;
    const rightX = margin + columnWidth + 60;

    // Client section (left)
    currentPage.drawText("[ Client ]", {
      x: leftX,
      y: signatureY,
      size: 12,
      font: fontBold,
      color: rgb(0, 0, 0),
    });

    currentPage.drawLine({
      start: { x: leftX, y: signatureY - 40 },
      end: { x: leftX + columnWidth, y: signatureY - 40 },
      thickness: 1,
      color: rgb(0, 0, 0),
    });

    currentPage.drawText("(Sign electronically via UPSMART)", {
      x: leftX,
      y: signatureY - 55,
      size: 9,
      font: fontRegular,
      color: rgb(0.4, 0.4, 0.4),
    });

    // Provider section (right)
    currentPage.drawText("[ Provider ]", {
      x: rightX,
      y: signatureY,
      size: 12,
      font: fontBold,
      color: rgb(0, 0, 0),
    });

    currentPage.drawLine({
      start: { x: rightX, y: signatureY - 40 },
      end: { x: rightX + columnWidth, y: signatureY - 40 },
      thickness: 1,
      color: rgb(0, 0, 0),
    });

    currentPage.drawText("(Sign electronically via UPSMART)", {
      x: rightX,
      y: signatureY - 55,
      size: 9,
      font: fontRegular,
      color: rgb(0.4, 0.4, 0.4),
    });

    return signatureY - 80; // Return new Y position after signature section
  };

  const lines = safeText.split("\n");

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check if we need a new page
    if (y < 70) {
      addFooter(page, pageNumber);
      page = pdfDoc.addPage();
      pageNumber++;
      y = height - 80;
      addHeader(page);
    }

    // Detect signature section - look for the line with [ Client ] and [ Provider ]
    if (line.includes("[ Client ]") && line.includes("[ Provider ]")) {
      // Ensure enough space for signature section
      if (y < 160) {
        addFooter(page, pageNumber);
        page = pdfDoc.addPage();
        pageNumber++;
        y = height - 80;
        addHeader(page);
      }

      y = drawSignatureSection(page, y);

      // Skip ALL following lines that are empty or contain signature text
      while (i + 1 < lines.length) {
        const nextLine = lines[i + 1];
        if (
          nextLine.trim() === "" ||
          nextLine.includes("(Sign electronically via UPSMART)")
        ) {
          i++; // Skip this line
        } else {
          break; // Stop skipping when we hit real content
        }
      }
      continue;
    }

    // Handle empty lines (paragraph breaks)
    if (line.trim() === "") {
      y -= lineHeight / 2;
      continue;
    }

    // Wrap long lines
    const wrappedLines = wrapText(line, maxWidth, fontRegular, bodyFontSize);

    for (const wrappedLine of wrappedLines) {
      if (y < 70) {
        addFooter(page, pageNumber);
        page = pdfDoc.addPage();
        pageNumber++;
        y = height - 80;
        addHeader(page);
      }

      page.drawText(wrappedLine, {
        x: margin,
        y,
        size: bodyFontSize,
        font: fontRegular,
        color: rgb(0, 0, 0),
      });

      y -= lineHeight;
    }
  }

  // Add footer to last page
  addFooter(page, pageNumber);

  const pdfBytes = await pdfDoc.save();

  return new NextResponse(pdfBytes, {
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `inline; filename="contract-${contractId}.pdf"`,
    },
  });
}
